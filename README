MPI FARM SKELETON

Project is in early stage of development, new features and tasks 
are added day by day.

== Features ==
- N-processors MPI2 task farm (one master and N-1 slaves)
- HDF5 (>1.8) storage
- reading config files with help of libreadconfig
- standard GNU/POSIX cmdline arg handling
- extensible interface with modules

== Requirements ==
- MPI2
- HDF5 > 1.8
- popt
- libreadconfig (distributed with the package)
- fortran compiler (some modules may require)
- c compiler

== Config options ==
- method: 0 - pixel by pixel, 6 - user defined
- xres/yres: x,y size of the farm, can be 1x100 or 10x10 etc
- name: name of the farm (also name of the hdf files)
- mrl: the length of the array returned to the master node

If default config file is not present, MpiFarm will use predefined defaults.
You can adjust any config option by commandline args.

If you want your slaves to read config files, please do it in your module.

== Commandline options ==
-p --module: loads additional module (module)
-c --config: reads given config file
-n --name: problem name
-m --method: method of pixel choice
-x --xres: x resolution
-y --yres: y resolution
-l --mrl: master result length
-d --dump: dump file [TODO]
-r --restart: restart mode [TODO]

== HDF data scheme ==
/config - all config data from config file
/board - map of computed pixels (0 - not computed, 1 - computed)
/data - output group data, size is defined in mpifarm_user.h by MAX_RESULT_LENGTH
/data/master - data received by the master node

Default module shows, how to write slave data to master datafile.

== Data ==
Master data vector is defined by struct( int coords[3], MY_DATATYPE res[mrl]).
It is the only vector received by master node and written to master data file. 
You can adjust the length of this vector by setting mrl.

TODO: allow to safely change MY_DATATYPE (currently its double).

You can create as many data files as needed, using User API from mpifarm_module_[MODULE_NAME].c. 
See mpifarm_module_default.c for examples. Each slave can have own config and datafile, too.

== Module architecture ==
You can write Your own module to MpiFarm and use it for computation.
Please refer to src/modules/default for examples.

Modules are loaded during runtime with commandline switch -p [--module=MODULE_NAME]

== User defined API functions ==
void [MODULE]_init(moduleInfo *md) [required]
void [MODULE]_cleanup() [required]

int [MODULE]_farmResolution(int xres, int yres)
- computes farm size

void [MODULE]_pixelCompute(int slave, configData *d, masterData *r) [required]
- computes given pixel

void [MODULE]_pixelCoords(int slave, int mastercoords[], configData *d, masterData *r)
- computes pixel for given slave (used only when method = 6) [required for method 6]

void [MODULE]_pixelCoordsMap(int ind[], int x, int y, int numofpixel)
- map coords function (used only when method = 6) [required for method 6]

void [MODULE]_masterIN(int mpi_size, configData *d)
- functions to do before farm start

void [MODULE]_masterOUT(int mpi_size, configData *d)
- functions to do after farm finish

void [MODULE]_slaveIN(int slave, configData *d, masterData *r)
- functions to do before slave start

void [MODULE]_slaveOUT(int slave, configData *d, masterData *r)
- functions to do after slave is finished

void [MODULE]_master_beforeSend(int slave, configData *d, masterData *r)
void [MODULE]_master_afterSend(int slave, configData *d, masterData *r)
void [MODULE]_master_beforeReceive(configData *d, masterData *r)
void [MODULE]_master_afterReceive(int slave, configData *d, masterData *r)
- functions to do before/after data send/receive (master)

void [MODULE]_slave_beforeSend(int slave, configData *d, masterData *r)
void [MODULE]_slave_afterSend(int slave, configData *d, masterData *r)
void [MODULE]_slave_beforeReceive(int slave, configData *d, masterData *r)
void [MODULE]_slave_afterReceive(int slave, configData *d, masterData *r)
- functions to do before/after data send/receive (slave)

Todo (too many to mention all...):
- restart
- file checking

== Creating sample module "hello" ==
It is really simple:)

Create to files: 
- mpifarm_module_hello.c
- mpifarm_module_hello.h

Main module files have to be named in that convention.

Now, edit c source code. Remember, each function must be prefixed with your module's name.
<code>
#include <mpifarm/mpifarm.h> //if your module isn't installed with MpiFarm
#include "mpifarm_module_hello.h" //and whatever libs you need

void hello_init(moduleInfo* md){
  //adjust module info here
  md->name = "hello";
  md->author = "Jeff";
  return;
}
void hello_cleanup(){
  return;
}

void hello_pixelCompute(int slave, configData *d, masterData *r){

  //here you can images much complicated computations, but for simplicity:
  r->res[0] = (double)r->coords[0];
  r->res[1] = (double)r->coords[1];
  r->res[2] = (double)r->coords[2];

  //use your skills to edit this function and make your module powerfull!

  return;
}

void hello_slaveOUT(int slave, configData *d, masterData *r){
  //slave can do something useful, for now, just tell us something
  printf("Hello from slave[%d]\n", slave);
  return;
}
</code>

Save the code. Now we need to build shared library and load it to MpiFarm.
<code>
mpicc -Wall -g -fPIC -c -o mpifarm_module_hello.o mpifarm_module_hello.c
mpicc -shared -o mpifarm_module_hello.so mpifarm_module_hello.o
</code>

To use the module, you need to adjust LD_LIBRARY_PATH to point to the module,
or copy it where ld can find it.

After that, you can load the module
<code>
mpirun -np 3 mpifarm -p hello
</code>

This example should is included in doc dir in file hello.tgz

Happy coding!


