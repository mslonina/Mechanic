MPI FARM SKELETON

== Features ==
- N-processors MPI2 task farm (one master and N-1 slaves)
- HDF5 (>1.8) storage
- reading config files with help of libreadconfig
- standard GNU/POSIX cmdline arg handling
- extensible interface with modules

== Requirements ==
- MPI2
- HDF5 > 1.8
- popt
- libreadconfig (distributed with the package)
- fortran compiler (some modules may require)
- c compiler

== Config options ==
- method: 0 - pixel by pixel, 6 - user defined
- xres/yres: x,y size of the farm, can be 1x100 or 10x10 etc
- name: name of the farm (also name of the hdf files)
- mrl: the length of the array returned to the master node

If default config file is not present, MpiFarm will use predefined defaults.
You can adjust any config option by commandline args.

If you want your slaves to read config files, please do it in your module.

== Commandline options ==
-m --module: loads additional module (module)
-c --config: reads given config file
-n --name: problem name
-x --xres: x resolution
-y --yres: y resolution
-l --mrl: master result length
-d --dump: dump file [TODO]
-r --restart: restart mode [TODO]

== HDF data scheme ==
/config - all config data from config file
/board - map of computed pixels (0 - not computed, 1 - computed)
/data - output group data, size is defined in mpifarm_user.h by MAX_RESULT_LENGTH
/data/master - data received by the master node

Default module shows, how to write slave data to master datafile.

== Data ==
Master data vector is defined by struct( int coords[3], MY_DATATYPE res[mrl]).
It is the only vector received by master node and written to master data file. 
You can adjust the length of this vector by setting mrl.

TODO: allow to safely change MY_DATATYPe (currently its double).

You can create as many data files as needed, using User API from mpifarm_module_[MODULE_NAME].c. 
See mpifarm_module_default.c for examples. Each slave can have own config and datafile, too.

== Module architecture ==
You can write Your own module to MpiFarm and use it for computation.
Please refer to src/modules/default for examples.

Modules are loaded during runtime with commandline switch -m [--module=MODULE_NAME]

== User defined API functions ==
void mpifarm_module_init() [required]
void mpifarm_module_cleanup() [required]

int userdefined_farmResolution(int xres, int yres)
- computes farm size

void userdefined_pixelCompute(int slave, configData *d, masterData *r) [required]
- computes given pixel

void userdefined_pixelCoords(int slave, int mastercoords[], configData *d, masterData *r)
- computes pixel for given slave (used only when method = 6) [required for method 6]

void userdefined_pixelCoordsMap(int ind[], int x, int y, int numofpixel)
- map coords function (used only when method = 6) [required for method 6]

void userdefined_masterIN(int mpi_size, configData *d)
- functions to do before farm start

void userdefined_masterOUT(int mpi_size, configData *d)
- functions to do after farm finish

void userdefined_slaveIN(int slave, configData *d, masterData *r)
- functions to do before slave start

void userdefined_slaveOUT(int slave, configData *d, masterData *r)
- functions to do after slave is finished

void userdefined_master_beforeSend(int slave, configData *d, masterData *r)
void userdefined_master_afterSend(int slave, configData *d, masterData *r)
void userdefined_master_beforeReceive(configData *d, masterData *r)
void userdefined_master_afterReceive(int slave, configData *d, masterData *r)
- functions to do before/after data send/receive (master)

void userdefined_slave_beforeSend(int slave, configData *d, masterData *r)
void userdefined_slave_afterSend(int slave, configData *d, masterData *r)
void userdefined_slave_beforeReceive(int slave, configData *d, masterData *r)
void userdefined_slave_afterReceive(int slave, configData *d, masterData *r)
- functions to do before/after data send/receive (slave)

Todo (too many to mention all...):
- restart
- file checking

== Creating sample module "hello" ==
It is really simple:)

Create to files: 
- mpifarm_module_hello.c
- mpifarm_module_hello.h

Main module files have to be named in that convention.

Now, edit c source code:
<code>
#include <mpifarm/mpifarm.h> //if your module isn't installed with MpiFarm
#include "mpifarm_module_hello.h" //and whatever libs you need

void mpifarm_module_init(){
  return;
}
void mpifarm_module_cleanup(){
  return;
}

void userdefined_pixelCompute(int slave, configData *d, masterData *r){

  //here you can images much complicated computations, but for simplicity:
  r->res[0] = (double)r->coords[0];
  r->res[1] = (double)r->coords[1];
  r->res[2] = (double)r->coords[2];

  //use your skills to edit this function and make your module powerfull!

  return;
}

void userdefined_slaveOUT(int slave, configData *d, masterData *r){
  //slave can do something useful, for now, just tell us something
  printf("Hello from slave[%d]\n", slave);
  return;
}
</code>

Save the code. Now we need to build shared library and load it to MpiFarm.
<code>
mpicc -Wall -g -fPIC -c -o mpifarm_module_hello.o mpifarm_module_hello.c
mpicc -shared -o mpifarm_module_hello.so mpifarm_module_hello.o
</code>

To use the module, you need to adjust LD_LIBRARY_PATH to point to the module,
or copy it where ld can find it.

After that, you can load the module
<code>
mpirun -np 3 mpifarm -p hello
</code>

This example should is included in doc dir in file hello.tgz

Happy coding!


