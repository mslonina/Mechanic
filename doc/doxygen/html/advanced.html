<html>
My header
<body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="advanced">Advanced Topics </a></h1><h2><a class="anchor" name="template-system">
The Template System</a></h2>
<code>Mechanic</code> uses some kind of a template system. It allows developer to use different sets of functions at different modes and/or nodes. Below we present list of available template functions and their possible overrides. Any modification of data on the master node will have a global effect. Modifications on slave nodes are only local until data is sended back to the master node.<h3><a class="anchor" name="nonmpi">
Non-MPI based functions (used in all modes)</a></h3>
<ul>
<li><code> module_node_in(int mpi_size, int node, moduleInfo* md, configData* d) </code> <br>
 This function is called before any operations on data are performed. The possible overrides are:<ul>
<li><code>module_master_in()</code> </li><li><code>module_slave_in()</code> (not in Masteralone mode)</li></ul>
</li></ul>
<p>
<ul>
<li><code> module_node_out(int mpi_size, int node, moduleInfo* md, configData* d) </code> <br>
 This function is called after all operations on data are finished. The possible overrides are:<ul>
<li><code>module_master_out()</code> </li><li><code>module_slave_out()</code> (not in Masteralone mode)</li></ul>
</li></ul>
<p>
<ul>
<li><code> module_node_before_processPixel(int node, moduleInfo* md, configData* d, <br>
 masterData* r) </code> <br>
 This function is called before computation of the pixel. The possible overrides are:<ul>
<li><code>module_master_beforeProcessPixel()</code> </li><li><code>module_slave_beforeProcessPixel()</code> (not in Masteralone mode)</li></ul>
</li></ul>
<p>
<ul>
<li><code> module_node_after_processPixel(int node, moduleInfo* md, configData* d, <br>
 masterData* r) </code> <br>
 This function is called before computation of the pixel. The possible overrides are:<ul>
<li><code>module_master_afterProcessPixel()</code> </li><li><code>module_slave_afterProcessPixel()</code> (not in Masteralone mode)</li></ul>
</li></ul>
<h3><a class="anchor" name="mpibased">
MPI-based functions (not used in Masteralone mode)</a></h3>
<ul>
<li><code> module_node_beforeSend(int node, moduleInfo* md, configData* d, <br>
 masterData* r) </code> <br>
 This function is called before any data send operation. In case of the master node, this will apply before sending the initial data to slave nodes, in case of slave nodes -- before sending the result data to the master node. The possible overrides are:<ul>
<li><code>module_master_beforeSend()</code> </li><li><code>module_slave_beforeSend()</code> </li></ul>
</li></ul>
<p>
<ul>
<li><code> module_node_afterSend(int node, moduleInfo* md, configData* d, <br>
 masterData* r) </code> <br>
 This function is called right after any data send operation. In case of the master node, this will apply after sending the initial data to slave nodes, in case of slave nodes -- after sending the result data to the master node. The possible overrides are:<ul>
<li><code>module_master_afterSend()</code> </li><li><code>module_slave_afterSend()</code> </li></ul>
</li></ul>
<p>
<ul>
<li><code> module_node_beforeReceive(int node, moduleInfo* md, configData* d, <br>
 masterData* r) </code> <br>
 This function is called just before the data is received. In case of the master node, this will apply on the result data from the previous computed pixel, in case of slave nodes -- on the initial and result data from the previous pixel (only locally). The possible overrides are:<ul>
<li><code>module_master_beforeReceive()</code> </li><li><code>module_slave_beforeReceive()</code> </li></ul>
</li></ul>
<p>
<ul>
<li><code> module_node_afterReceive(int node, moduleInfo* md, configData* d, <br>
 masterData* r) </code> <br>
 This function is called right after the data is received. In case of the master node, this will apply on the result data, in case of slave nodes -- on the initial data. The possible overrides are:<ul>
<li><code>module_master_afterReceive()</code> </li><li><code>module_slave_afterReceive()</code> </li></ul>
</li></ul>
<p>
Each template function is optional, so <code>Mechanic</code> will silently skip it if it is missing. Refer to <a class="el" href="advanced.html#echo">The Echo Module</a> for a simple example of using the template system.<h3><a class="anchor" name="modulecasestudies">
Case Studies</a></h3>
There are some basic use cases of The Template System:<p>
<ul>
<li><b> Each slave does the same.</b> This is the simplest case of using <code>Mechanic</code>. The only thing to do is to define <code>processPixel()</code> function and return data to the master node with <code>masterData</code> structure. You can also do something more in <code>node_in/out</code> functions, but in that case it is not really necessary.</li></ul>
<p>
<ul>
<li><b> Each slave has different config file.</b> This time you need to read config file for each slave separately. This can be done with <code>LRC</code> in <code>slave_in()</code> function and config files named after slave number, i.e. slave22.</li></ul>
<p>
<ul>
<li><b> Each slave has different <code>processPixel</code> function.</b> At this point you need to create some subfunctions of <code>processPixel</code> and choose them accordingly to number of the slave, i.e. in the switch routine.</li></ul>
<p>
<ul>
<li><b> Each slave has both different config file and different <code>processPixel</code>.</b> Just combining two cases in simple switch routines and it should work.</li></ul>
<h2><a class="anchor" name="echo">
The Echo Module</a></h2>
Here we present possible usage of the template system. We will use <code>node_in()</code> and <code>node_out()</code> functions as examples.<p>
We implement <code>node_in()</code> and <code>node_out()</code> functions as follows:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> echo_node_in(<span class="keywordtype">int</span> mpi_size, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata){

   mechanic_message(MECHANIC_MESSAGE_INFO, <span class="stringliteral">"NodeIN [%d]\n"</span>, node);

   <span class="keywordflow">return</span> 0;
 }
</pre></div><p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> echo_node_out(<span class="keywordtype">int</span> mpi_size, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   mechanic_message(MECHANIC_MESSAGE_INFO, <span class="stringliteral">"NodeOUT [%d]\n"</span>, node);

   <span class="keywordflow">return</span> 0;
 }
</pre></div><p>
They will be used if no override is present. However, we can create overrides. For the master node we have:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> echo_master_in(<span class="keywordtype">int</span> mpi_size, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata){

   <span class="keywordflow">return</span> 0;
 }
</pre></div><p>
which will override the output of <code>node_in()</code> on the master node. We can create a much more complicated function, as for the <code>node_in()</code> at slave node:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> echo_slave_in(<span class="keywordtype">int</span> mpi_size, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   hid_t sfile_id, gid, string_type;
   hid_t dataset, dataspace;
   hid_t rank = 1;
   hsize_t dimens_1d;
   herr_t serr;
   <span class="keywordtype">char</span> sbase[] = <span class="stringliteral">"slave"</span>;
   <span class="keywordtype">char</span> nodename[512];
   <span class="keywordtype">char</span> gbase[] = <span class="stringliteral">"slave"</span>;
   <span class="keywordtype">char</span> group[512];
   <span class="keywordtype">char</span> oldfile[1028];

   <span class="keywordtype">char</span> cbase[] = <span class="stringliteral">"Hello from slave "</span>;
   <span class="keywordtype">char</span> comment[1024];

   <span class="keyword">struct </span>stat st;

   mechanic_message(MECHANIC_MESSAGE_INFO, <span class="stringliteral">"ECHO IN: %s\n"</span>, d-&gt;name);
   sprintf(nodename, <span class="stringliteral">"%s-%s%d.h5"</span>, d-&gt;name, sbase, node);
   sprintf(group, <span class="stringliteral">"%s%d"</span>, gbase, node);

   <span class="keywordflow">if</span> (stat(nodename,&amp;st) == 0) {
       sprintf(oldfile, <span class="stringliteral">"old-%s"</span>, nodename);
       rename(nodename,oldfile);
   }

   sfile_id = H5Fcreate(nodename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
   gid = H5Gcreate(sfile_id, group, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);

   sprintf(comment, <span class="stringliteral">"%s%d. "</span>, cbase, node);
   string_type = H5Tcopy(H5T_C_S1);
   H5Tset_size(string_type, strlen(comment));

   rank = 1;
   dimens_1d = 1;

   dataspace = H5Screate_simple(rank, &amp;dimens_1d, NULL);

   dataset = H5Dcreate(gid, <span class="stringliteral">"comment"</span>, string_type, dataspace, H5P_DEFAULT,
       H5P_DEFAULT, H5P_DEFAULT);
   serr = H5Dwrite(dataset, string_type, H5S_ALL, dataspace, H5P_DEFAULT,
       comment);

   H5Sclose(dataspace);
   H5Dclose(dataset);
   H5Gclose(gid);
   H5Fclose(sfile_id);

   <span class="keywordflow">return</span> 0;
 }
</pre></div><p>
This function use advantage of <code>HDF</code> storage. Each slave will create its own data file and print a comment to it.<p>
Now, after all pixel have been computed, we tell our master node to copy slave data files to the master data file, as shown below:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> echo_master_out(<span class="keywordtype">int</span> nodes, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   <span class="keywordtype">int</span> i = 0;
   hid_t fname, masterfile, masterdatagroup;
   herr_t stat;
   <span class="keywordtype">char</span> groupname[512];
   <span class="keywordtype">char</span> filename[512];

   stat = H5open();

   mechanic_message(MECHANIC_MESSAGE_INFO, <span class="stringliteral">"ECHO MASTER IN: %s\n"</span>, d-&gt;datafile);
   masterfile = H5Fopen(d-&gt;datafile, H5F_ACC_RDWR, H5P_DEFAULT);
   masterdatagroup = H5Gopen(masterfile, <span class="stringliteral">"data"</span>, H5P_DEFAULT);

   <span class="keywordflow">for</span> (i = 1; i &lt; nodes; i++) {
     sprintf(groupname, <span class="stringliteral">"slave%d"</span>, i);
     sprintf(filename, <span class="stringliteral">"%s-slave%d.h5"</span>, d-&gt;name, i);

     fname = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);
     stat = H5Ocopy(fname, groupname, masterdatagroup, groupname,
         H5P_DEFAULT, H5P_DEFAULT);
     <span class="keywordflow">if</span> (stat &lt; 0) mechanic_message(MECHANIC_MESSAGE_ERR, <span class="stringliteral">"copy error\n"</span>);

     H5Fclose(fname);

   }

   H5Gclose(masterdatagroup);
   H5Fclose(masterfile);
   stat = H5close();

   mechanic_message(MECHANIC_MESSAGE_INFO,
       <span class="stringliteral">"Master process [%d] OVER &amp; OUT.\n"</span>, node);

   <span class="keywordflow">return</span> 0;
 }
</pre></div><p>
At the end of simulation, the slave node will print customized message: <div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> echo_slave_out(<span class="keywordtype">int</span> mpi_size, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   mechanic_message(MECHANIC_MESSAGE_INFO, <span class="stringliteral">"SLAVE[%d] OVER &amp; OUT\n"</span>, node);

   <span class="keywordflow">return</span> 0;
 }
</pre></div><h2><a class="anchor" name="mandelbrot">
The Mandelbrot Module</a></h2>
This module shows how to use basic api of <code>Mechanic</code> to compute any numerical problem, in that case -- the Mandelbrot fractal.<p>
We use here only 3 functions: <code>mandelbrot_init()</code>, <code>mandelbrot_cleanup()</code> and <code>mandelbrot_processPixel()</code>. There is an additional function, <code>mandelbrot_generateFractal()</code>, which shows that you can even add external functions to your module, since it is a standard C code.<p>
In addition, the module returns the number of node that computed the pixel.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "mechanic.h"</span>
<span class="preprocessor"> #include "mechanic_module_mandelbrot.h"</span>

 <span class="keywordtype">int</span> mandelbrot_init(moduleInfo *md){

   md-&gt;mrl = 4;
   md-&gt;irl = 4;

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> mandelbrot_cleanup(moduleInfo *md){

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> mandelbrot_processPixel(<span class="keywordtype">int</span> slave, moduleInfo *md, configData* d,
     masterData* inidata, masterData* r){

   <span class="keywordtype">double</span> real_min, real_max, imag_min, imag_max;
   <span class="keywordtype">double</span> scale_real, scale_imag;
   <span class="keywordtype">double</span> c;

   real_min = -2.0;
   real_max = 2.0;
   imag_min = -2.0;
   imag_max = 2.0;
   c = 4.0;

   scale_real = (real_max - real_min) / ((<span class="keywordtype">double</span>) d-&gt;xres - 1.0);
   scale_imag = (imag_max - imag_min) / ((<span class="keywordtype">double</span>) d-&gt;yres - 1.0);

   r-&gt;res[0] = real_min + r-&gt;coords[0] * scale_real;
   r-&gt;res[1] = imag_max - r-&gt;coords[1] * scale_imag;

   r-&gt;res[2] = mandelbrot_generateFractal(r-&gt;res[0], r-&gt;res[1], c);

   r-&gt;res[3] = (double) slave;

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> mandelbrot_generateFractal(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> c){

   <span class="keywordtype">double</span> temp, lengthsq;
   <span class="keywordtype">int</span> max_iter = 256;
   <span class="keywordtype">int</span> count = 0;
   <span class="keywordtype">double</span> zr = 0.0, zi = 0.0;

   <span class="keywordflow">do</span>{

     temp = zr*zr - zi*zi + a;
     zi = 2*zr*zi + b;
     zr = temp;
     lengthsq = zr*zr + zi*zi;
     count++;

   } <span class="keywordflow">while</span> ((lengthsq &lt; c) &amp;&amp; (count &lt; max_iter));

   <span class="keywordflow">return</span> count;
 }
</pre></div><p>
The header file: <div class="fragment"><pre class="fragment"><span class="preprocessor"> #ifndef MECHANIC_MODULE_MANDELBROT_H</span>
<span class="preprocessor"></span><span class="preprocessor"> #define MECHANIC_MODULE_MANDELBROT_H</span>
<span class="preprocessor"></span>
<span class="preprocessor"> #include &lt;stdio.h&gt;</span>
<span class="preprocessor"> #include &lt;stdlib.h&gt;</span>

 <span class="keywordtype">int</span> mandelbrot_generateFractal(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> c);

<span class="preprocessor"> #endif</span>
</pre></div><h2><a class="anchor" name="method6">
The Method 6</a></h2>
You can change default <code>Mechanic</code> pixel mapping and simulation handling by setting <code> method = 6 </code>. In this case, you need to provide additional functions in your module. If any of them is missing, <code>Mechanic</code> will abort.<p>
The <code>farmResolution()</code> simply returns number of simulations to do.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> module_farmResolution(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, moduleInfo* md, configData* d){

   <span class="keywordflow">return</span> x*y;
 }
</pre></div><p>
The <code>pixelCoordsMap()</code> operates on <code>t</code> index and should return 0 on success, errcode otherwise. The default behaviour is to map pixels on 2D board, as shown below:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> module_pixelCoordsMap(<span class="keywordtype">int</span> t[], <span class="keywordtype">int</span> numofpx, <span class="keywordtype">int</span> xres, <span class="keywordtype">int</span> yres, moduleInfo* md,
     configData* d){

   <span class="keywordflow">if</span> (numofpx &lt; yres) {
     t[0] = numofpx / yres;
     t[1] = numofpx;
   }

   <span class="keywordflow">if</span> (numofpx &gt; yres - 1) {
     t[0] = numofpx / yres;
     t[1] = numofpx % yres;
   }

   <span class="keywordflow">return</span> 0;
 }
</pre></div><p>
The <code>pixelCoords()</code> assigns pixel coordinates to <code> masterData r</code> structure. The default behaviour is to copy <code>t</code> index to <code> r-&gt;coords </code>.<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> module_pixelCoords(<span class="keywordtype">int</span> node, <span class="keywordtype">int</span> t[], moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   r-&gt;coords[0] = t[0];
   r-&gt;coords[1] = t[1];
   r-&gt;coords[2] = t[2];

   <span class="keywordflow">return</span> 0;
 }
</pre></div><h2><a class="anchor" name="showdata">
Working with Data</a></h2>
In this section you will find some tips and tricks of using data stored by <code>Mechanic</code>.<h3><a class="anchor" name="gnuplot">
Gnuplot</a></h3>
There are only three steps to prepare your data for Gnuplot:<p>
1. Dump data from HDF5 file: <div class="fragment"><pre class="fragment"> h5dump -d /data/master -y -w 100 -o output.dat mechanic-data.h5 
</pre></div> 2. Remove commas from <code>output.dat:</code> <div class="fragment"><pre class="fragment"> sed -s <span class="stringliteral">'s/,/ /g'</span> output.dat 
</pre></div> 3. For <code>pm3d</code> maps (200 is just your vertical resolution): <div class="fragment"><pre class="fragment"> sed <span class="stringliteral">"0~200G"</span> output.dat &gt; pm3d_file.dat 
</pre></div><p>
You can process <code>output.dat</code> / <code>pm3d_file.dat</code> in the way you like.<h2><a class="anchor" name="orbit">
The Orbit Library</a></h2>
The Orbit Library was created to handle common tasks meet in Celestial Mechanics, i.e. orbital elements conversion. The library provides following functions:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">double</span> orbit_kepler(<span class="keywordtype">int</span> precision, <span class="keywordtype">double</span> e, <span class="keywordtype">double</span> m);
 <span class="keywordtype">double</span> orbit_kepler_iteration(<span class="keywordtype">int</span> precision, <span class="keywordtype">double</span> e, <span class="keywordtype">double</span> m, <span class="keywordtype">double</span> E);
 <span class="keywordtype">int</span> orbit_el2rv(<span class="keywordtype">int</span> precision, <span class="keywordtype">double</span> gm, <span class="keywordtype">double</span> el[], <span class="keywordtype">double</span> rv[]);
 <span class="keywordtype">int</span> orbit_rv2el(<span class="keywordtype">double</span> gm, <span class="keywordtype">double</span> el[], <span class="keywordtype">double</span> rv[]);
 <span class="keywordtype">int</span> orbit_kepler2cart(<span class="keywordtype">int</span> direction, <span class="keywordtype">int</span> precision, <span class="keywordtype">int</span> nb,
     <span class="keywordtype">double</span> gm, <span class="keywordtype">double</span> el[], <span class="keywordtype">double</span> rv[]);
 <span class="keywordtype">int</span> orbit_baryrv2baryrp(<span class="keywordtype">int</span> direction, <span class="keywordtype">double</span> mass, <span class="keywordtype">double</span> rv[], <span class="keywordtype">double</span> rp[]);
 <span class="keywordtype">int</span> orbit_helio2bary(<span class="keywordtype">int</span> direction, <span class="keywordtype">double</span> mass[], <span class="keywordtype">double</span> hrv[], <span class="keywordtype">double</span> brv[]);
 <span class="keywordtype">int</span> orbit_helio2poincare(<span class="keywordtype">int</span> direction, <span class="keywordtype">double</span> mass[], <span class="keywordtype">double</span> hrv[], <span class="keywordtype">double</span> prv[]);

 <span class="keywordtype">double</span> deg2rad(<span class="keywordtype">double</span> angle);
 <span class="keywordtype">double</span> rad2deg(<span class="keywordtype">double</span> angle);

 <span class="keywordtype">int</span> mbv(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> ndim, <span class="keywordtype">double</span> a[x][y], <span class="keywordtype">double</span> b[y], <span class="keywordtype">double</span> c[x]);
 <span class="keywordtype">int</span> mbm(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z, <span class="keywordtype">int</span> dima, <span class="keywordtype">int</span> dimb, <span class="keywordtype">int</span> dimc,
     <span class="keywordtype">double</span> a[x][y], <span class="keywordtype">double</span> b[y][z], <span class="keywordtype">double</span> c[x][z]);
</pre></div><p>
The parameters are:<ul>
<li><code>el</code>[] -- input/output orbital elements. The array should have following shape: <div class="fragment"><pre class="fragment">   el[0] - a
   el[1] - e
   el[2] - i [radians]
   el[3] - capomega [radians]
   el[4] - omega [radians]
   el[5] - mean anomally [radians]
</pre></div></li></ul>
<p>
<ul>
<li><code>rv</code>[] -- input/output rv frame. The array should have following shape: <div class="fragment"><pre class="fragment">   rv[0] - x
   rv[1] - y
   rv[2] - z
   rv[3] - vx
   rv[4] - vy
   rv[5] - vz
</pre></div></li><li><code>gm</code> -- mass parameter</li><li><code>e</code> -- eccentricity</li><li><code>m</code> -- mean anomaly</li><li><code>E</code> -- initial solution for Kepler's equation</li><li><code>precision</code> -- the precision used to solve Kepler's equation</li><li><code>direction</code> -- direction of elements conversion, 1: el[] -&gt; rv[], -1 rv[] -&gt; el[]</li><li><code>angle</code> -- angle to convert</li></ul>
<p>
The Kepler's equation is solved using Danby's approach, see J.M.A. Danby, "The Solution of Kepler's Equation, III", Cel. Mech. 40 (1987) pp. 303-312.<p>
To use <code>Orbit</code>, you need to include <code>mechanic/mechanic_lib_orbit.h</code> in your code and link it to <code>libmechanic_orbit.so</code>.<h2><a class="anchor" name="fortran">
The Fortran 2003 Bindings</a></h2>
You can create Fortran 2003 module for <code>Mechanic</code> using provided Fortran bindings. Below is an example of Fortran module.<p>
<div class="fragment"><pre class="fragment"> module ff

   use iso_c_binding
   use mechanic_fortran

 contains

   integer (c_int) function ff_init(md) &amp;
     bind(c, name = 'ff_init') result(errcode)

     implicit none
     type(moduleInfo), intent(inout) :: md

     md%mrl = 3

     errcode = 0
   end function ff_init

   integer (c_int) function ff_cleanup(md) &amp;
     bind(c, name = 'ff_cleanup') result(errcode)

     implicit none
     type(moduleInfo), intent(in) :: md

     write(*,*) "End module fortran:)"
     errcode = 0

   end function ff_cleanup

   integer (c_int) function ff_processPixel(node, md, d, r) &amp;
     bind(c, name = 'ff_processPixel') result(errcode)

     implicit none
     integer(c_int), intent(in) :: node
     type(moduleInfo), intent(in) :: md
     type(configData), intent(in) :: d
     type(masterData), intent(inout) :: r
     integer :: res_rank(1)

     real (c_double), pointer :: res_array(:)

     res_rank = md%mrl
     call c_f_pointer(r%res, res_array, res_rank)

     res_array(1) = 22.0d0
     res_array(2) = 32.0d0
     res_array(3) = 42.0d0

     errcode = 0
   end function ff_processPixel

 end module ff
</pre></div><h3><a class="anchor" name="f2003ref">
Fortran 2003 bindings reference</a></h3>
The Fortran 2003 bindings provide the same API as C headers, as follows:<ul>
<li>Error codes <div class="fragment"><pre class="fragment">     INTEGER :: MECHANIC_ERR_MPI_F = 911
     INTEGER :: MECHANIC_ERR_HDF_F = 912
     INTEGER :: MECHANIC_ERR_MODULE_F = 913
     INTEGER :: MECHANIC_ERR_SETUP_F = 914
     INTEGER :: MECHANIC_ERR_MEM_F = 915
     INTEGER :: MECHANIC_ERR_CHECKPOINT_F = 916
     INTEGER :: MECHANIC_ERR_OTHER_F = 999
</pre></div></li><li>ModuleInfo structure <div class="fragment"><pre class="fragment">     type, bind(c) :: moduleInfo
       integer (c_int) :: mrl
     end type moduleInfo
</pre></div></li><li>ConfigData structure <div class="fragment"><pre class="fragment">     type, bind(c) :: configData
       character(kind = c_char) :: p_name
       character(kind = c_char) :: datafile
       character(kind = c_char) :: u_module
       integer (c_int) :: xres
       integer (c_int) :: yres
       integer (c_int) :: method
       integer (c_int) :: checkpoint
       integer (c_int) :: restartmode
       integer (c_int) :: mode
     end type configData
</pre></div></li><li>MasterData structure <div class="fragment"><pre class="fragment">     type, bind(c) :: masterData
       type (c_ptr) :: res
       integer (c_int) :: coords(3)
     end type masterData
</pre></div></li><li>API functions <div class="fragment"><pre class="fragment"></pre></div> </li></ul>
</div>
</body>
My footer
</html>
