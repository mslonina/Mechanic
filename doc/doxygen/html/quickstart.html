<html>
My header
<body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1><a class="anchor" name="quickstart">Getting Started </a></h1>To understand what <code>Mechanic</code> is and what it does, let us write a well-known "Hello World!". We will create small C library, let us call it <code>Hello</code> and save it in <code>mechanic_module_hello.c</code> file:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "mechanic.h"</span>
<span class="preprocessor"> #include "mechanic_module_hello.h"</span>

 <span class="keywordtype">int</span> hello_init(moduleInfo* md){

   md-&gt;irl = 3;
   md-&gt;mrl = 6;

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> hello_cleanup(moduleInfo* md){

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> hello_master_in(<span class="keywordtype">int</span> mpi_size, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata) {

   inidata-&gt;res[0] = 99.0;

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> hello_master_preparePixel(<span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r) {

   inidata-&gt;res[1] = (double) d-&gt;xres;

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> hello_slave_preparePixel(<span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r) {

   inidata-&gt;res[2] = (double) node;

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> hello_processPixel(<span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r)
 {

   r-&gt;res[0] = (double) r-&gt;coords[0];
   r-&gt;res[1] = (<span class="keywordtype">double</span>) r-&gt;coords[1];
   r-&gt;res[2] = (double) r-&gt;coords[2];
   r-&gt;res[3] = inidata-&gt;res[0];
   r-&gt;res[4] = inidata-&gt;res[1];
   r-&gt;res[5] = inidata-&gt;res[2];

   <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> hello_slave_out(<span class="keywordtype">int</span> nodes, <span class="keywordtype">int</span> node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   mechanic_message(MECHANIC_MESSAGE_INFO, <span class="stringliteral">"Hello from slave[%d]\n"</span>, node);

   <span class="keywordflow">return</span> 0;
 }
</pre></div><p>
We need to compile the example code to a shared library. We can do that by calling<p>
<div class="fragment"><pre class="fragment"> gcc -fPIC -c mechanic_module_hello.c -o mechanic_module_hello.o
 gcc -shared mechanic_module_hello.o -o libmechanic_module_hello.so
</pre></div><p>
<code>Mechanic</code> need to know, where our module is, so we need to adjust <code>LD_LIBRARY_PATH</code> (it depends on shell you are using) to the place we saved our module. If you are a <code>Bash</code> user, try the following setting in your <code> .bashrc </code> file:<p>
<div class="fragment"><pre class="fragment"> export LD_LIBRARY_PATH=/usr/lib/:/usr/local/lib:.
</pre></div><p>
We run <code>Mechanic</code> with our module by<p>
<div class="fragment"><pre class="fragment"> mpirun -np 3 mechanic -p hello
</pre></div><p>
This will tell <code>Mechanic</code> to run on three nodes, in a task farm mode, with one master node and two slaves. The master node will send default initial condition (pixel coordinates) to each slave and receive data in <code>masterData</code> structure (in this case the coordinates of the pixel).<p>
The output should be similar to:<p>
<div class="fragment"><pre class="fragment"> -&gt; Mechanic
    v. 0.12-UNSTABLE-2
    Author: MSlonina, TCfA, NCU
    Bugs: mariusz.slonina@gmail.com
    http:<span class="comment">//mechanics.astri.umk.pl/projects/mechanic</span>
 !! Config file not specified/doesn<span class="stringliteral">'t exist. Will use defaults.</span>
<span class="stringliteral"> -&gt; Mechanic will use these startup values:</span>
<span class="stringliteral"> (...)</span>
<span class="stringliteral"> -&gt; Hello from slave[1]</span>
<span class="stringliteral"> -&gt; Hello from slave[2]</span>
</pre></div><p>
Two last lines were printed using our simple module. In the working directory you should find also <code>mechanic-master-00.h5</code> file. It is a data file written by the master node, and each run of <code>Mechanic</code> will produce such file. It containes all information about the setup of the simulation and data received from slaves.<p>
If you try<p>
<div class="fragment"><pre class="fragment"> h5dump -n mechanic-master-00.h5
</pre></div><p>
you should see the following output:<p>
<div class="fragment"><pre class="fragment"> HDF5 <span class="stringliteral">"mechanic-master.h5"</span> {
 FILE_CONTENTS {
  group      /
  dataset    /board
  group      /config
  dataset    /config/<span class="keywordflow">default</span>
  dataset    /config/logs
  group      /data
  dataset    /data/master
  }
 }
</pre></div><p>
which describes the data storage in master file. There are two additional files in the working dir with suffixes 01 and 02 -- these are checkpoint files, see <a class="el" href="quickstart.html#checkpoint">Checkpoints</a> for detailes.<p>
The <code>Hello</code> module is included in <code>Mechanic</code> distribution as a simple example of using the software.<h2><a class="anchor" name="hello">
The Hello Module</a></h2>
Let us go step-by-step throught the <code>Hello</code> module. Each <code>Mechanic</code> module must contain the preprocessor directive<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "mechanic.h"</span>
</pre></div><p>
The module specific header file<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "mechanic_module_hello.h"</span>
</pre></div><p>
is optional. Since each module is a normal C code, you can also use any other headers and link to any other library during compilation.<p>
Every function in the module is prefixed with the name of the module -- thus, you should use unique names for your modules. The file name prefix, <code>mechanic_module_</code> is required for proper module loading.<p>
The first three functions:<p>
<ul>
<li><code>hello_init()</code> </li><li><code>hello_cleanup()</code> </li><li><code>hello_processPixel()</code> </li></ul>
<p>
are required for the module to work. <code>Mechanic</code> will abort if any of them is missing. The fourth one, <code>hello_slave_out()</code> is optional and belongs to the templateable functions group (see <a class="el" href="advanced.html#template-system">The Template System</a>).<p>
Each function should return an integer value, 0 on success and errcode on failure, which is important for proper error handling.<p>
<ul>
<li><code>hello_init(moduleInfo* md)</code> is called on module initialization and you need to provide some information about the module, especially, <code>md-&gt;mrl</code>, which is the length of the results array sended from the slave node to master node. The <code>moduleInfo</code> type contains information about the module, and will be extended in the future. The structure is available for all module functions. The <code>moduleInfo</code> type has the following shape: <div class="fragment"><pre class="fragment">   <span class="keyword">typedef</span> <span class="keyword">struct </span>{
     <span class="keywordtype">int</span> irl;
     <span class="keywordtype">int</span> mrl;
   } moduleInfo;
</pre></div></li></ul>
<p>
<ul>
<li><code>hello_cleanup(moduleInfo* md)</code> currently does nothing, however, it is required for future development.</li></ul>
<p>
<ul>
<li><code>hello_processPixel(int node, moduleInfo* md, configData* d, masterData* r)</code> is the heart of your module. Here you can compute almost any type of numerical problem or even you can call external application from here. There are technically no contradictions for including Fortran based code. In this simple example we just assign coordinates of the simulation (see <a class="el" href="quickstart.html#coords">Pixel-coordinate System</a>) to the result array <code>r-&gt;res</code>. The array is defined in <code>masterData</code> structure, as follows:</li></ul>
<p>
<div class="fragment"><pre class="fragment">   <span class="keyword">typedef</span> <span class="keyword">struct </span>{
     MECHANIC_DATATYPE *res;
     <span class="keywordtype">int</span> coords[3]; <span class="comment">/* 0 - x 1 - y 2 - number of the pixel */</span>
   } masterData;
</pre></div><p>
Currently, <code>MECHANIC_DATATYPE</code> is set to <code>double</code>, so we need to do proper casting from integer to double. The result array has the <code>md-&gt;mrl</code> size, in this case 3. The <code>masterData</code> structure is available for all module functions.<p>
<ul>
<li><code>hello_slave_out(int nodes, int node, moduleInfo* md, configData* d, masterData* r)</code> prints formatted message from the slave node on the screen, after the node did its job. The <code>mechanic_message()</code> (see <a class="el" href="devel.html">Short Developer's Guide</a>) is available for all modules, and can be used for printing different kinds of messages, i.e. some debug information or warning.</li></ul>
<p>
The <code>Mechanic</code> package contains few other modules:<p>
<ul>
<li><code>Module</code> -- the default module with all available functions included</li><li><code>Echo</code> -- an extended version of the <code>Hello</code> module, which includes some advanced stuff on handling data files, and is an example of using template system</li><li><code>Mandelbrot</code> -- a benchmark module, which computes The Mandelbrot fractal.</li></ul>
<h2><a class="anchor" name="setup">
The Setup System</a></h2>
<code>Mechanic</code> uses standard configuration path -- first, we read defaults, then the config file and command line options. The latter two are optional, and if not present, the code will use defaults fixed at compilation time.<p>
To find out what command line options are available, try<p>
<div class="fragment"><pre class="fragment"> mpirun -np 3 mechanic --help
</pre></div><p>
The configuration data is available to slave nodes by the structure: <div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
   <span class="keywordtype">char</span>* name;
   <span class="keywordtype">char</span>* datafile;
   <span class="keywordtype">char</span>* module;
   <span class="keywordtype">int</span> xres;
   <span class="keywordtype">int</span> yres;
   <span class="keywordtype">int</span> method;
   <span class="keywordtype">int</span> checkpoint;
   <span class="keywordtype">int</span> restartmode;
   <span class="keywordtype">int</span> mode;
 } configData;
</pre></div><h3><a class="anchor" name="cli">
Command Line Options</a></h3>
The full list of command line options is included below:<p>
<ul>
<li><code>--help</code> <code>--usage</code> <code> -?</code> -- prints help message</li><li><code>--name</code> <code>-n</code> -- the problem name, it will be used to prefix all data files specific in given run</li><li><code>--config</code> <code>-c</code> -- config file to use in the run</li><li><code>--module</code> <code>-p</code> -- module which should be used during the run</li><li><code>--method</code> <code>-m</code> -- pixel mapping method (0 -- default, 6 -- user-defined)</li><li><code>--xres</code> <code>-x</code> -- x resolution of the simulation map</li><li><code>--yres</code> <code>-y</code> -- y resolution of the simulation map</li><li><code>--checkpoint</code> <code>-d</code> -- checkpoint file write interval</li></ul>
<p>
<code>Mechanic</code> provides user with a checkpoint system, see <a class="el" href="quickstart.html#checkpoint">Checkpoints</a> for detailes. In this case the options are:<p>
<ul>
<li><code>--restart</code> <code>-r</code> -- switch to restart mode and use checkpoint file</li></ul>
<p>
Mechanic can operate in different modes, see <a class="el" href="quickstart.html#modes">Modes</a> for detailes. You can switch between them by using:<p>
<ul>
<li><code>-0</code> -- masteralone mode</li><li><code>-1</code> -- MPI task farm mode</li><li><code>-2</code> -- multi task farm mode</li></ul>
<h3><a class="anchor" name="configfile">
Config File</a></h3>
<code>Mechanic</code> uses <code>LRC</code> for handling config files. To load configuration from custom config file use <code>-c</code> or <code>--config</code> switch. If this option is set, but the file doesn't exist, <code>Mechanic</code> will abort. Sample config file is given below:<p>
<div class="fragment"><pre class="fragment"> [<span class="keywordflow">default</span>]
 name = hello
 xres = 4 #must be greater than 0
 yres = 4 #must be greater than 0
 method = 0 #single pixel -- 0, userdefined -- 6
 module = hello # modules: hello, echo, mandelbrot, module
 mode = 1 # masteralone -- 0, task farm -- 1, multi task farm -- 2

 [logs]
 checkpoint = 4
</pre></div><p>
The config file options are equivalents of command line options. Any other option will be silently ommited. If any of the variables is missing, <code>Mechanic</code> will use defaults for each not found variable. Namespaces are mandatory and <code>Mechanic</code> will abort if missing. The errors are handled by <code>LRC</code> in this case.<p>
You can include full or inline comments in your file, just after the comment mark <code>#</code>. The configuration is stored in the master file, see <a class="el" href="quickstart.html#storage">Data Storage Scheme</a>.<h3><a class="anchor" name="setup-examples">
Examples</a></h3>
The general rule for running <code>Mechanic</code> is to use:<p>
<div class="fragment"><pre class="fragment"> mpirun -np NUMBER_OF_CPUS_TO_USE mechanic [OPTIONS]
</pre></div><p>
Here we provide and explain some simple examples:<ul>
<li><code> mpirun -np 4 mechanic -p mandelbrot -x 200 -y 200 -n fractal</code> <br>
 <code>Mechanic</code> will use 4 nodes in MPI task farm mode (one master and three slaves) and will compute the Mandelbrot fractal with resolution 200x200 pixels. The name of the run will be "fractal".</li><li><code> mpirun -np 4 mechanic -p mandelbrot -x 200 -y 200 -n fractal -0</code> <br>
 This is a similar example, in this case <code>Mechanic</code> will compute the fractal in masteralone mode. Slave nodes will be terminated.</li><li><code> mpirun -np 4 mechanic -p mandelbrot -x 1 -y 1</code> <br>
 Here we can do only one simulation using the <code>Mandelbrot</code> module. In this case, slave nodes 2 and 3 will be terminated (see <a class="el" href="quickstart.html#modes">Modes</a>).</li><li><code> mpirun -np 4 mechanic -p application -x 100 -y 1</code> <br>
 We can also create a one-dimensional simulation map, by setting one of the axes to 1. This is especially useful in non-image computations, such as observation reduction -- we can call <code>Mechanic</code> to perform tasks i.e. on 100 stars.</li><li><code> mpirun -np 1 mechanic [OPTIONS]</code> <br>
 <code> mechanic [OPTIONS]</code> <br>
 <code>Mechanic</code> will automatically switch to masteralone mode.</li></ul>
<h2><a class="anchor" name="coords">
Pixel-coordinate System</a></h2>
<code>Mechanic</code> was created for handling simulations related to dynamical maps. Thus, it uses 2D pixel coordinate system (there are plans for extending it to other dimensions). This was the simplest way to show which simulations have been computed and which not. The map is stored in <code>/board</code> table in the master file. Each finished simulation is marked with 1, the ongoing or broken -- with 0.<p>
It is natural to use <code></code>(x,y)-resolution option (either in the config file or command line) to describe the map of pixels for an image (like a dynamical map or the Mandelbrot fractal). However, one can use slice-based mapping, by using i.e. <code>100x1</code> or <code>1x100</code> resolution. In either case, the result should be the same. Setting <code> (x,y) = (1,1)</code> is equivalent of doing only one simulation.<p>
The mapping should help you in setting initial conditions for the simulation, i.e. we can change some values by using pixel coordinates or the number of the pixel. This information is available during the computation and is stored in <code>masterData</code> struct.<p>
By default, the number of simulations is counted by multiplying x and y resolution. The simulations are currently done one-by-one, the master node does not participate in computations (except masteralone mode, see <a class="el" href="quickstart.html#modes">Modes</a>). You can change default behaviour by using <code> method = 6</code>, see <a class="el" href="advanced.html#method6">The Method 6</a>.<h2><a class="anchor" name="modes">
Modes</a></h2>
<code>Mechanic</code> can compute simulations both in single-cpu mode (masteralone) or multi-cpu mode (MPI task farm).<p>
<ul>
<li><b> Masteralone mode</b> -- This mode is especially useful if you run <code>Mechanic</code> in single-cpu environment. If the mode is used in multi-cpu environments and the size of MPI group is greater than 1, <code>Mechanic</code> will terminate all nodes but the master node.</li></ul>
<p>
<ul>
<li><b> MPI Task farm</b> -- The classical, and default mode for <code>Mechanic</code>. This will use one master node and number of slave nodes to do simulations. The master node is responsible for sending/receiving data and storing them. If number of slave nodes is greater than number of simulations to do, all unused nodes will be terminated.</li></ul>
<p>
<ul>
<li><b> MPI MultiTask farm</b> -- This is an extension of MPI Task farm. Here, we split our spool into parts with own sub-master node. The master node sends and receives data from sub-master nodes. Then, the scenario is the same as in MPI Task farm. Note: this mode will not be done until <code>Unstable-4</code> release.</li></ul>
<h2><a class="anchor" name="storage">
Data Storage Scheme</a></h2>
<code>Mechanic</code> writes data in the following scheme:<p>
<ul>
<li><code>/config</code> -- configuration file (written by <code>LRC</code> API)</li><li><code>/board</code> -- simulation mapping</li><li><code>/data</code> -- main data group</li><li><code>/data/master</code> -- master dataset, contains data received from nodes.</li></ul>
<p>
The file can be viewed with <code>hdftools</code>, i.e. <code>h5dump</code>. The master file has always <code>problemname-master.h5</code> name. If the master file exists in the current working dir, it will be automatically backuped.<p>
The Parallel HDF has no support for MPI task farm, thus the only node allowed to write master file is the master node. However, the module can provide additional data files and operate on them, see <a class="el" href="advanced.html#echo">The Echo Module</a> for the example.<h2><a class="anchor" name="checkpoint">
Checkpoints</a></h2>
<code>Mechanic</code> comes with integrated checkpoint system, which helps with master file backup and restarting simulations. By default, the checkpoint file write interval is setuped to 2000, which means, that data will be stored in the master file after each 2000 pixel have been reached. You can change this interval by setting <code>checkpoint</code> in config file or using <code>--checkpoint</code> <code>-d</code> in the command line.<p>
<code>Mechanic</code> will create up to 3 checkpoint file, in the well-known incremental backup system. Each file will have a corresponding checkpoint number (starting from the master file, 00, up to 02).<p>
You can use any of the checkpoint files to restart your simulation. To use restart mode, try <code>--restart</code> or <code>-r</code> command line option and provide the path to the checkpoint file to use. If the file is not usable, <code>Mechanic</code> will abort.<p>
In restart mode <code>Mechanic</code> will do only not previously finished simulations. At this stage of development, it is not possible to restart partially done simulations. </div>
</body>
My footer
</html>
