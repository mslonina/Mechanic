\subsection{The Template System}\label{advanced_template-system}
{\tt Mechanic} uses some kind of a template system. It allows developer to use different sets of functions at different modes and/or nodes. Below we present list of available template functions and their possible overrides. Any modification of data on the master node will have a global effect. Modifications on slave nodes are only local until data is sended back to the master node.\subsubsection{Non-MPI based functions (used in all modes)}\label{advanced_nonmpi}
\begin{itemize}
\item {\tt  module\_\-node\_\-in(int mpi\_\-size, int node, moduleInfo$\ast$ md, configData$\ast$ d) } \par
 This function is called before any operations on data are performed. The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-in()} \item {\tt module\_\-slave\_\-in()} (not in Masteralone mode)\end{itemize}
\end{itemize}


\begin{itemize}
\item {\tt  module\_\-node\_\-out(int mpi\_\-size, int node, moduleInfo$\ast$ md, configData$\ast$ d) } \par
 This function is called after all operations on data are finished. The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-out()} \item {\tt module\_\-slave\_\-out()} (not in Masteralone mode)\end{itemize}
\end{itemize}


\begin{itemize}
\item {\tt  module\_\-node\_\-before\_\-processPixel(int node, moduleInfo$\ast$ md, configData$\ast$ d, \par
 masterData$\ast$ r) } \par
 This function is called before computation of the pixel. The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-beforeProcessPixel()} \item {\tt module\_\-slave\_\-beforeProcessPixel()} (not in Masteralone mode)\end{itemize}
\end{itemize}


\begin{itemize}
\item {\tt  module\_\-node\_\-after\_\-processPixel(int node, moduleInfo$\ast$ md, configData$\ast$ d, \par
 masterData$\ast$ r) } \par
 This function is called before computation of the pixel. The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-afterProcessPixel()} \item {\tt module\_\-slave\_\-afterProcessPixel()} (not in Masteralone mode)\end{itemize}
\end{itemize}
\subsubsection{MPI-based functions (not used in Masteralone mode)}\label{advanced_mpibased}
\begin{itemize}
\item {\tt  module\_\-node\_\-beforeSend(int node, moduleInfo$\ast$ md, configData$\ast$ d, \par
 masterData$\ast$ r) } \par
 This function is called before any data send operation. In case of the master node, this will apply before sending the initial data to slave nodes, in case of slave nodes -- before sending the result data to the master node. The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-beforeSend()} \item {\tt module\_\-slave\_\-beforeSend()} \end{itemize}
\end{itemize}


\begin{itemize}
\item {\tt  module\_\-node\_\-afterSend(int node, moduleInfo$\ast$ md, configData$\ast$ d, \par
 masterData$\ast$ r) } \par
 This function is called right after any data send operation. In case of the master node, this will apply after sending the initial data to slave nodes, in case of slave nodes -- after sending the result data to the master node. The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-afterSend()} \item {\tt module\_\-slave\_\-afterSend()} \end{itemize}
\end{itemize}


\begin{itemize}
\item {\tt  module\_\-node\_\-beforeReceive(int node, moduleInfo$\ast$ md, configData$\ast$ d, \par
 masterData$\ast$ r) } \par
 This function is called just before the data is received. In case of the master node, this will apply on the result data from the previous computed pixel, in case of slave nodes -- on the initial and result data from the previous pixel (only locally). The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-beforeReceive()} \item {\tt module\_\-slave\_\-beforeReceive()} \end{itemize}
\end{itemize}


\begin{itemize}
\item {\tt  module\_\-node\_\-afterReceive(int node, moduleInfo$\ast$ md, configData$\ast$ d, \par
 masterData$\ast$ r) } \par
 This function is called right after the data is received. In case of the master node, this will apply on the result data, in case of slave nodes -- on the initial data. The possible overrides are:\begin{itemize}
\item {\tt module\_\-master\_\-afterReceive()} \item {\tt module\_\-slave\_\-afterReceive()} \end{itemize}
\end{itemize}


Each template function is optional, so {\tt Mechanic} will silently skip it if it is missing. Refer to \doxyref{The Echo Module}{p.}{advanced_echo} for a simple example of using the template system.\subsubsection{Case Studies}\label{advanced_modulecasestudies}
There are some basic use cases of The Template System:

\begin{itemize}
\item {\bf  Each slave does the same.} This is the simplest case of using {\tt Mechanic}. The only thing to do is to define {\tt processPixel()} function and return data to the master node with {\tt masterData} structure. You can also do something more in {\tt node\_\-in/out} functions, but in that case it is not really necessary.\end{itemize}


\begin{itemize}
\item {\bf  Each slave has different config file.} This time you need to read config file for each slave separately. This can be done with {\tt LRC} in {\tt slave\_\-in()} function and config files named after slave number, i.e. slave22.\end{itemize}


\begin{itemize}
\item {\bf  Each slave has different {\tt processPixel} function.} At this point you need to create some subfunctions of {\tt processPixel} and choose them accordingly to number of the slave, i.e. in the switch routine.\end{itemize}


\begin{itemize}
\item {\bf  Each slave has both different config file and different {\tt processPixel}.} Just combining two cases in simple switch routines and it should work.\end{itemize}
\subsection{The Echo Module}\label{advanced_echo}
Here we present possible usage of the template system. We will use {\tt node\_\-in()} and {\tt node\_\-out()} functions as examples.

We implement {\tt node\_\-in()} and {\tt node\_\-out()} functions as follows:



\begin{Code}\begin{verbatim} int echo_node_in(int mpi_size, int node, moduleInfo* md, configData* d,
     masterData* inidata){

   mechanic_message(MECHANIC_MESSAGE_INFO, "NodeIN [%d]\n", node);

   return 0;
 }
\end{verbatim}
\end{Code}





\begin{Code}\begin{verbatim} int echo_node_out(int mpi_size, int node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   mechanic_message(MECHANIC_MESSAGE_INFO, "NodeOUT [%d]\n", node);

   return 0;
 }
\end{verbatim}
\end{Code}



They will be used if no override is present. However, we can create overrides. For the master node we have:



\begin{Code}\begin{verbatim} int echo_master_in(int mpi_size, int node, moduleInfo* md, configData* d,
     masterData* inidata){

   return 0;
 }
\end{verbatim}
\end{Code}



which will override the output of {\tt node\_\-in()} on the master node. We can create a much more complicated function, as for the {\tt node\_\-in()} at slave node:



\begin{Code}\begin{verbatim} int echo_slave_in(int mpi_size, int node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   hid_t sfile_id, gid, string_type;
   hid_t dataset, dataspace;
   hid_t rank = 1;
   hsize_t dimens_1d;
   herr_t serr;
   char sbase[] = "slave";
   char nodename[512];
   char gbase[] = "slave";
   char group[512];
   char oldfile[1028];

   char cbase[] = "Hello from slave ";
   char comment[1024];

   struct stat st;

   mechanic_message(MECHANIC_MESSAGE_INFO, "ECHO IN: %s\n", d->name);
   sprintf(nodename, "%s-%s%d.h5", d->name, sbase, node);
   sprintf(group, "%s%d", gbase, node);

   if (stat(nodename,&st) == 0) {
       sprintf(oldfile, "old-%s", nodename);
       rename(nodename,oldfile);
   }

   sfile_id = H5Fcreate(nodename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT);
   gid = H5Gcreate(sfile_id, group, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);

   sprintf(comment, "%s%d. ", cbase, node);
   string_type = H5Tcopy(H5T_C_S1);
   H5Tset_size(string_type, strlen(comment));

   rank = 1;
   dimens_1d = 1;

   dataspace = H5Screate_simple(rank, &dimens_1d, NULL);

   dataset = H5Dcreate(gid, "comment", string_type, dataspace, H5P_DEFAULT,
       H5P_DEFAULT, H5P_DEFAULT);
   serr = H5Dwrite(dataset, string_type, H5S_ALL, dataspace, H5P_DEFAULT,
       comment);

   H5Sclose(dataspace);
   H5Dclose(dataset);
   H5Gclose(gid);
   H5Fclose(sfile_id);

   return 0;
 }
\end{verbatim}
\end{Code}



This function use advantage of {\tt HDF} storage. Each slave will create its own data file and print a comment to it.

Now, after all pixel have been computed, we tell our master node to copy slave data files to the master data file, as shown below:



\begin{Code}\begin{verbatim} int echo_master_out(int nodes, int node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   int i = 0;
   hid_t fname, masterfile, masterdatagroup;
   herr_t stat;
   char groupname[512];
   char filename[512];

   stat = H5open();

   mechanic_message(MECHANIC_MESSAGE_INFO, "ECHO MASTER IN: %s\n", d->datafile);
   masterfile = H5Fopen(d->datafile, H5F_ACC_RDWR, H5P_DEFAULT);
   masterdatagroup = H5Gopen(masterfile, "data", H5P_DEFAULT);

   for (i = 1; i < nodes; i++) {
     sprintf(groupname, "slave%d", i);
     sprintf(filename, "%s-slave%d.h5", d->name, i);

     fname = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);
     stat = H5Ocopy(fname, groupname, masterdatagroup, groupname,
         H5P_DEFAULT, H5P_DEFAULT);
     if (stat < 0) mechanic_message(MECHANIC_MESSAGE_ERR, "copy error\n");

     H5Fclose(fname);

   }

   H5Gclose(masterdatagroup);
   H5Fclose(masterfile);
   stat = H5close();

   mechanic_message(MECHANIC_MESSAGE_INFO,
       "Master process [%d] OVER & OUT.\n", node);

   return 0;
 }
\end{verbatim}
\end{Code}



At the end of simulation, the slave node will print customized message: 

\begin{Code}\begin{verbatim} int echo_slave_out(int mpi_size, int node, moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   mechanic_message(MECHANIC_MESSAGE_INFO, "SLAVE[%d] OVER & OUT\n", node);

   return 0;
 }
\end{verbatim}
\end{Code}

\subsection{The Mandelbrot Module}\label{advanced_mandelbrot}
This module shows how to use basic api of {\tt Mechanic} to compute any numerical problem, in that case -- the Mandelbrot fractal.

We use here only 3 functions: {\tt mandelbrot\_\-init()}, {\tt mandelbrot\_\-cleanup()} and {\tt mandelbrot\_\-processPixel()}. There is an additional function, {\tt mandelbrot\_\-generateFractal()}, which shows that you can even add external functions to your module, since it is a standard C code.

In addition, the module returns the number of node that computed the pixel.



\begin{Code}\begin{verbatim} #include "mechanic.h"
 #include "mechanic_module_mandelbrot.h"

 int mandelbrot_init(moduleInfo *md){

   md->mrl = 4;
   md->irl = 4;

   return 0;
 }

 int mandelbrot_cleanup(moduleInfo *md){

   return 0;
 }

 int mandelbrot_processPixel(int slave, moduleInfo *md, configData* d,
     masterData* inidata, masterData* r){

   double real_min, real_max, imag_min, imag_max;
   double scale_real, scale_imag;
   double c;

   real_min = -2.0;
   real_max = 2.0;
   imag_min = -2.0;
   imag_max = 2.0;
   c = 4.0;

   scale_real = (real_max - real_min) / ((double) d->xres - 1.0);
   scale_imag = (imag_max - imag_min) / ((double) d->yres - 1.0);

   r->res[0] = real_min + r->coords[0] * scale_real;
   r->res[1] = imag_max - r->coords[1] * scale_imag;

   r->res[2] = mandelbrot_generateFractal(r->res[0], r->res[1], c);

   r->res[3] = (double) slave;

   return 0;
 }

 int mandelbrot_generateFractal(double a, double b, double c){

   double temp, lengthsq;
   int max_iter = 256;
   int count = 0;
   double zr = 0.0, zi = 0.0;

   do{

     temp = zr*zr - zi*zi + a;
     zi = 2*zr*zi + b;
     zr = temp;
     lengthsq = zr*zr + zi*zi;
     count++;

   } while ((lengthsq < c) && (count < max_iter));

   return count;
 }
\end{verbatim}
\end{Code}



The header file: 

\begin{Code}\begin{verbatim} #ifndef MECHANIC_MODULE_MANDELBROT_H
 #define MECHANIC_MODULE_MANDELBROT_H

 #include <stdio.h>
 #include <stdlib.h>

 int mandelbrot_generateFractal(double a, double b, double c);

 #endif
\end{verbatim}
\end{Code}

\subsection{The Method 6}\label{advanced_method6}
You can change default {\tt Mechanic} pixel mapping and simulation handling by setting {\tt  method = 6 }. In this case, you need to provide additional functions in your module. If any of them is missing, {\tt Mechanic} will abort.

The {\tt farmResolution()} simply returns number of simulations to do.



\begin{Code}\begin{verbatim} int module_farmResolution(int x, int y, moduleInfo* md, configData* d){

   return x*y;
 }
\end{verbatim}
\end{Code}



The {\tt pixelCoordsMap()} operates on {\tt t} index and should return 0 on success, errcode otherwise. The default behaviour is to map pixels on 2D board, as shown below:



\begin{Code}\begin{verbatim} int module_pixelCoordsMap(int t[], int numofpx, int xres, int yres, moduleInfo* md,
     configData* d){

   if (numofpx < yres) {
     t[0] = numofpx / yres;
     t[1] = numofpx;
   }

   if (numofpx > yres - 1) {
     t[0] = numofpx / yres;
     t[1] = numofpx % yres;
   }

   return 0;
 }
\end{verbatim}
\end{Code}



The {\tt pixelCoords()} assigns pixel coordinates to {\tt  masterData r} structure. The default behaviour is to copy {\tt t} index to {\tt  r-$>$coords }.



\begin{Code}\begin{verbatim} int module_pixelCoords(int node, int t[], moduleInfo* md, configData* d,
     masterData* inidata, masterData* r){

   r->coords[0] = t[0];
   r->coords[1] = t[1];
   r->coords[2] = t[2];

   return 0;
 }
\end{verbatim}
\end{Code}

\subsection{Working with Data}\label{advanced_showdata}
In this section you will find some tips and tricks of using data stored by {\tt Mechanic}.\subsubsection{Gnuplot}\label{advanced_gnuplot}
There are only three steps to prepare your data for Gnuplot:

1. Dump data from HDF5 file: 

\begin{Code}\begin{verbatim} h5dump -d /data/master -y -w 100 -o output.dat mechanic-data.h5 
\end{verbatim}
\end{Code}

 2. Remove commas from {\tt output.dat:} 

\begin{Code}\begin{verbatim} sed -s 's/,/ /g' output.dat 
\end{verbatim}
\end{Code}

 3. For {\tt pm3d} maps (200 is just your vertical resolution): 

\begin{Code}\begin{verbatim} sed "0~200G" output.dat > pm3d_file.dat 
\end{verbatim}
\end{Code}



You can process {\tt output.dat} / {\tt pm3d\_\-file.dat} in the way you like.\subsection{The Orbit Library}\label{advanced_orbit}
The Orbit Library was created to handle common tasks meet in Celestial Mechanics, i.e. orbital elements conversion. The library provides following functions:



\begin{Code}\begin{verbatim} double orbit_kepler(int precision, double e, double m);
 double orbit_kepler_iteration(int precision, double e, double m, double E);
 int orbit_el2rv(int precision, double gm, double el[], double rv[]);
 int orbit_rv2el(double gm, double el[], double rv[]);
 int orbit_kepler2cart(int direction, int precision, int nb,
     double gm, double el[], double rv[]);
 int orbit_baryrv2baryrp(int direction, double mass, double rv[], double rp[]);
 int orbit_helio2bary(int direction, double mass[], double hrv[], double brv[]);
 int orbit_helio2poincare(int direction, double mass[], double hrv[], double prv[]);

 double deg2rad(double angle);
 double rad2deg(double angle);

 int mbv(int x, int y, int ndim, double a[x][y], double b[y], double c[x]);
 int mbm(int x, int y, int z, int dima, int dimb, int dimc,
     double a[x][y], double b[y][z], double c[x][z]);
\end{verbatim}
\end{Code}



The parameters are:\begin{itemize}
\item {\tt el}[] -- input/output orbital elements. The array should have following shape: 

\begin{Code}\begin{verbatim}   el[0] - a
   el[1] - e
   el[2] - i [radians]
   el[3] - capomega [radians]
   el[4] - omega [radians]
   el[5] - mean anomally [radians]
\end{verbatim}
\end{Code}

\end{itemize}


\begin{itemize}
\item {\tt rv}[] -- input/output rv frame. The array should have following shape: 

\begin{Code}\begin{verbatim}   rv[0] - x
   rv[1] - y
   rv[2] - z
   rv[3] - vx
   rv[4] - vy
   rv[5] - vz
\end{verbatim}
\end{Code}

\item {\tt gm} -- mass parameter\item {\tt e} -- eccentricity\item {\tt m} -- mean anomaly\item {\tt E} -- initial solution for Kepler's equation\item {\tt precision} -- the precision used to solve Kepler's equation\item {\tt direction} -- direction of elements conversion, 1: el[] -$>$ rv[], -1 rv[] -$>$ el[]\item {\tt angle} -- angle to convert\end{itemize}


The Kepler's equation is solved using Danby's approach, see J.M.A. Danby, \char`\"{}The Solution of Kepler's Equation, III\char`\"{}, Cel. Mech. 40 (1987) pp. 303-312.

To use {\tt Orbit}, you need to include {\tt mechanic/mechanic\_\-lib\_\-orbit.h} in your code and link it to {\tt libmechanic\_\-orbit.so}.\subsection{The Fortran 2003 Bindings}\label{advanced_fortran}
You can create Fortran 2003 module for {\tt Mechanic} using provided Fortran bindings. Below is an example of Fortran module.



\begin{Code}\begin{verbatim} module ff

   use iso_c_binding
   use mechanic_fortran

 contains

   integer (c_int) function ff_init(md) &
     bind(c, name = 'ff_init') result(errcode)

     implicit none
     type(moduleInfo), intent(inout) :: md

     md%mrl = 3

     errcode = 0
   end function ff_init

   integer (c_int) function ff_cleanup(md) &
     bind(c, name = 'ff_cleanup') result(errcode)

     implicit none
     type(moduleInfo), intent(in) :: md

     write(*,*) "End module fortran:)"
     errcode = 0

   end function ff_cleanup

   integer (c_int) function ff_processPixel(node, md, d, r) &
     bind(c, name = 'ff_processPixel') result(errcode)

     implicit none
     integer(c_int), intent(in) :: node
     type(moduleInfo), intent(in) :: md
     type(configData), intent(in) :: d
     type(masterData), intent(inout) :: r
     integer :: res_rank(1)

     real (c_double), pointer :: res_array(:)

     res_rank = md%mrl
     call c_f_pointer(r%res, res_array, res_rank)

     res_array(1) = 22.0d0
     res_array(2) = 32.0d0
     res_array(3) = 42.0d0

     errcode = 0
   end function ff_processPixel

 end module ff
\end{verbatim}
\end{Code}

\subsubsection{Fortran 2003 bindings reference}\label{advanced_f2003ref}
The Fortran 2003 bindings provide the same API as C headers, as follows:\begin{itemize}
\item Error codes 

\begin{Code}\begin{verbatim}     INTEGER :: MECHANIC_ERR_MPI_F = 911
     INTEGER :: MECHANIC_ERR_HDF_F = 912
     INTEGER :: MECHANIC_ERR_MODULE_F = 913
     INTEGER :: MECHANIC_ERR_SETUP_F = 914
     INTEGER :: MECHANIC_ERR_MEM_F = 915
     INTEGER :: MECHANIC_ERR_CHECKPOINT_F = 916
     INTEGER :: MECHANIC_ERR_OTHER_F = 999
\end{verbatim}
\end{Code}

\item ModuleInfo structure 

\begin{Code}\begin{verbatim}     type, bind(c) :: moduleInfo
       integer (c_int) :: mrl
     end type moduleInfo
\end{verbatim}
\end{Code}

\item ConfigData structure 

\begin{Code}\begin{verbatim}     type, bind(c) :: configData
       character(kind = c_char) :: p_name
       character(kind = c_char) :: datafile
       character(kind = c_char) :: u_module
       integer (c_int) :: xres
       integer (c_int) :: yres
       integer (c_int) :: method
       integer (c_int) :: checkpoint
       integer (c_int) :: restartmode
       integer (c_int) :: mode
     end type configData
\end{verbatim}
\end{Code}

\item MasterData structure 

\begin{Code}\begin{verbatim}     type, bind(c) :: masterData
       type (c_ptr) :: res
       integer (c_int) :: coords(3)
     end type masterData
\end{verbatim}
\end{Code}

\item API functions 

\begin{Code}\begin{verbatim}\end{verbatim}
\end{Code}

 \end{itemize}
