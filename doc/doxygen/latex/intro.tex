Handling numerical simulations is not a trivial task, either in one- or multi-cpu environments. It can be a very stressfull job, especially when you deal with many sets of initial conditions (like in many dynamical problems) and is full of human-based mistakes.

Our main research is focused on studying dynamics of planetary systems, thus it requires numerical job to be carefully done. Most of the problems can be coded by hand, in fact, we did it in that way many times, however you can easily find that most of these task are in some way, or in some part, repeatable.

Let's have an example: We want to study the dynamics of a four body problem -- we have a star, two massive planets and a big gap between them. We want to know the dynamical behaviour (stability or not) of a test earth-like body in the gap. We can observe the behaviour by using some values of semimajor axis and eccentricity of the small planet and check the state of the system after some time. Then, we can change these values by a small delta and observe the state of the system again. If we repeat it in some range of semimajor axes and in some range of eccentricities we will get a dynamical map of the planetary system (one can exchange semimajor axis and eccentricity by other orbital elements, too). Each pixel of the map is a standalone numerical simulation which takes some time on one cpu.

Now, the first approach is to use one cpu to do all the stuff. However, if computation of the pixel lasts too long (especially when the configuration is quite stable), the creation of the dynamical map is a very long process, and can take not one or two weeks, but one or two months.

There is a second approach. Let's say, we have not one, but 10 cpus. If we can handle sending initial conditions and receiving results, we can create the dynamical map of the system at least 10 times faster!

And that's the reason we created {\tt Mechanic}. We needed some kind of a numerical interface or framework that will handle our dynamical studies. We started by creating simple MPI Task farm model, however we quickly realised that using MPI framework can be useful not only in image-based operations (dynamical map is a some kind of an image), but also in many numerical problems with huge sets of initial conditions, or even tasks like observations reductions, which lasts too long on single cpu. We found that our interface should handle such situations, too.

Now, {\tt Mechanic} is a multi-purpose numerical framework and interface. It is written in C99 with help of MPI and HDF5 storage. It provides extensible user API and loadable module support -- each numerical problem can be coded as a standalone module, loaded dynamically during runtime. {\tt Mechanic} uses {\tt LibReadConfig} ({\tt LRC}) for handling configuration aspects and {\tt Popt} library for command line ({\tt CLI}) options.

{\tt Mechanic} is in pre-alpha stage, this means, that there are some bugs in code, some parts are not finished, and some features are not implemented yet. However, we try to keep the {\tt Master} branch as stable and useful as possible. Feel free to participate in the development, test the software and send bugs. The latest snapshot can be grabbed from {\tt http://git.astri.umk.pl.} The {\tt Experimental} branch containes all bleeding-edge stuff.

{\tt Mechanic} is distributed under terms od BSD license. This means you can use our software both for personal and commercial stuff. We released the code to the public, because we believe, that the science and its tools should be open for everyone. If you find {\tt Mechanic} useful for your research, we will be appreciated if you refer to this user guide and our project homepage: {\tt http://mechanics.astri.umk.pl/project/mechanic.}

In this userguide, we assume you have some basic knowledge on C-programming and using Unix-shell. 